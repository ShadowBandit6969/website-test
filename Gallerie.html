<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Open-World Galerie – Demo</title>
  <style>
    html, body { height: 100%; margin: 0; }
    body { background: #0b0f16; color: #e8eefc; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; overflow: hidden; }

    /* Fullscreen stage */
    #stage { position: fixed; inset: 0; display: block; width: 100vw; height: 100vh; }

    /* UI overlay */
    .hud { position: fixed; left: 16px; bottom: 16px; background: rgba(9,12,18,.7); border: 1px solid rgba(255,255,255,.08); padding: 10px 12px; border-radius: 10px; backdrop-filter: blur(6px); user-select: none; }
    .hud h1 { margin: 0 0 6px; font-size: 14px; letter-spacing: .02em; color: #bcd3ff; }
    .hud p { margin: 0; font-size: 12px; line-height: 1.35; color: #cbd5e1; }

    .badge { position: fixed; right: 16px; top: 16px; font-size: 12px; color: #9bb4ff; background: rgba(9,12,18,.6); border: 1px solid rgba(255,255,255,.08); padding: 8px 10px; border-radius: 999px; }

    /* Minimap */
    .minimap { position: fixed; right: 16px; bottom: 16px; width: 160px; height: 120px; border-radius: 12px; background: rgba(9,12,18,.7); border: 1px solid rgba(255,255,255,.08); overflow: hidden; }
    .minimap canvas { width: 100%; height: 100%; display: block; }

    @media (hover: none) { .hud p.kb { display: none; } }
  </style>
</head>
<body>
  <canvas id="stage" aria-label="Open-World Galerie" role="application"></canvas>

  <div class="badge">Open-World Galerie · toroidal (nahtlos)</div>

  <div class="hud" aria-live="polite">
    <h1>Navigation</h1>
    <p class="kb">WASD/↔↕ & Scroll/Trackpad bewegen · Maus/Touch ziehen · Klick auf Bild → Firmen-Unterseite</p>
    <p>Am Rand geht’s nahtlos weiter – echte Open-World.</p>
  </div>

  <div class="minimap" aria-hidden="true"><canvas id="mini"></canvas></div>

  <script>
  // ============ CONFIG ============
  const WORLD = { width: 6000, height: 4000 }; // wrap-around
  const ITEM_COUNT = 25;
  const ITEM_SIZE = [140, 320];
  const MOVE_SPEED = 600; // px/s (Tastatur)
  const WHEEL_SPEED = 1.0; // Multiplier für Wheel/Trackpad

  // Spur/Trail
  const TRAIL = {
    maxPoints: 1600,
    sampleEvery: 0.05,   // schnelleres Sampling
    fadeSeconds: 14,
    minMove: 0.5,        // sehr kleine Bewegung reicht bereits
    points: [],
    tSince: 0
  };

  // ============ ITEMS ============
  const items = Array.from({ length: ITEM_COUNT }).map((_, i) => ({
    id: i,
    src: `./GallerieItems/item${i + 1}.png`,
    link: `https://example.com/unterseite/${i + 1}`, // anpassen
    x: Math.random() * WORLD.width,
    y: Math.random() * WORLD.height,
    w: Math.round(ITEM_SIZE[0] + Math.random() * (ITEM_SIZE[1] - ITEM_SIZE[0])),
    h: Math.round(ITEM_SIZE[0] + Math.random() * (ITEM_SIZE[1] - ITEM_SIZE[0])),
    img: null,
  }));

  // ============ CANVAS SETUP ============
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  const canvas = document.getElementById('stage');
  const ctx = canvas.getContext('2d', { alpha: true });

  const miniCanvas = document.getElementById('mini');
  const miniCtx = miniCanvas.getContext('2d');

  function resize() {
    const { innerWidth: w, innerHeight: h } = window;
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    miniCanvas.width = 160 * dpr;
    miniCanvas.height = 120 * dpr;
    miniCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener('resize', resize);
  resize();

  // ============ LOAD IMAGES ============
  function loadAll() {
    return Promise.all(items.map(it => new Promise(res => {
      const im = new Image();
      im.decoding = 'async';
      im.loading = 'lazy';
      im.src = it.src;
      im.onload = () => { it.img = im; res(); };
      im.onerror = () => { it.img = null; res(); };
    })));
  }

  // ============ INPUT ============
  const keyMap = { ArrowUp:'up', ArrowDown:'down', ArrowLeft:'left', ArrowRight:'right', w:'up', a:'left', s:'down', d:'right' };
  const keys = new Set();
  window.addEventListener('keydown', (e) => { const k = keyMap[e.key]; if (k) { keys.add(k); e.preventDefault(); } });
  window.addEventListener('keyup',   (e) => { const k = keyMap[e.key]; if (k) { keys.delete(k); e.preventDefault(); } });

  let dragging = false; let lastPointer = null;
  function pointerPos(ev){ if (ev.touches && ev.touches[0]) return { x: ev.touches[0].clientX, y: ev.touches[0].clientY }; return { x: ev.clientX, y: ev.clientY }; }
  canvas.addEventListener('mousedown', (e)=>{ dragging = true; lastPointer = pointerPos(e); });
  window.addEventListener('mouseup', ()=>{ dragging = false; lastPointer = null; });
  window.addEventListener('mousemove', (e)=>{
    if(!dragging) return; const p = pointerPos(e);
    if(lastPointer){ camera.x -= (p.x - lastPointer.x); camera.y -= (p.y - lastPointer.y); registerTrailSample(true); wrapCamera(); }
    lastPointer = p;
  });

  canvas.addEventListener('touchstart', (e)=>{ dragging = true; lastPointer = pointerPos(e); }, {passive: true});
  window.addEventListener('touchend', ()=>{ dragging = false; lastPointer = null; }, {passive: true});
  window.addEventListener('touchmove', (e)=>{
    if(!dragging) return; const p = pointerPos(e);
    if(lastPointer){ camera.x -= (p.x - lastPointer.x); camera.y -= (p.y - lastPointer.y); registerTrailSample(true); wrapCamera(); }
    lastPointer = p;
  }, {passive: true});

  // Scroll/Trackpad zum Pannen
  window.addEventListener('wheel', (e)=>{
    // Standard: deltaY nach unten → nach unten bewegen; deltaX für horizontales Panning
    camera.x += (e.deltaX) * WHEEL_SPEED;
    camera.y += (e.deltaY) * WHEEL_SPEED;
    registerTrailSample(true);
    wrapCamera();
    e.preventDefault();
  }, { passive: false });

  // Klick → Link
  canvas.addEventListener('click', (e)=>{
    const rect = canvas.getBoundingClientRect();
    const sx = e.clientX - rect.left; // CSS px
    const sy = e.clientY - rect.top;
    for (let i = drawnRects.length - 1; i >= 0; i--) {
      const r = drawnRects[i];
      if (sx >= r.x && sx <= r.x + r.w && sy >= r.y && sy <= r.y + r.h) {
        if (r.item && r.item.link) { window.location.href = r.item.link; }
        return;
      }
    }
  });

  // ============ WORLD / CAMERA ============
  function wrap(n, max){ return (n % max + max) % max; }

  // Kamera wird nach Bild-Laden auf Item 1 gesetzt
  const camera = { x: 0, y: 0 };

  function wrapCamera(){
    const oldX = camera.x, oldY = camera.y;
    camera.x = wrap(camera.x, WORLD.width);
    camera.y = wrap(camera.y, WORLD.height);
    // Bei Wrap Sprung → Trail-Segment brechen
    const dx = Math.abs(camera.x - oldX), dy = Math.abs(camera.y - oldY);
    if (dx > WORLD.width * 0.5 || dy > WORLD.height * 0.5) {
      if (TRAIL.points.length) TRAIL.points[TRAIL.points.length - 1].break = true;
    }
  }

  // ============ TRAIL ============
  function registerTrailSample(force = false, dt = 0){
    TRAIL.tSince += dt;
    const last = TRAIL.points[TRAIL.points.length - 1];
    const moved = !last || distWrapped(camera.x, camera.y, last.x, last.y) >= TRAIL.minMove;

    if (force || (TRAIL.tSince >= TRAIL.sampleEvery && moved)) {
      TRAIL.tSince = 0;
      TRAIL.points.push({ x: camera.x, y: camera.y, t: performance.now()/1000, break: false });
      if (TRAIL.points.length > TRAIL.maxPoints) TRAIL.points.shift();
    }
  }

  function distWrapped(x1,y1,x2,y2){
    let dx = Math.abs(x1 - x2), dy = Math.abs(y1 - y2);
    dx = Math.min(dx, WORLD.width - dx);
    dy = Math.min(dy, WORLD.height - dy);
    return Math.hypot(dx, dy);
  }

  // ============ RENDER ============
  let drawnRects = []; // wird pro Frame gefüllt (zur Klickprüfung)

  function drawBackground(w, h){
    const tile = 200;
    const ox = - (camera.x % tile);
    const oy = - (camera.y % tile);

    // Hintergrund
    ctx.fillStyle = '#0b0f16';
    ctx.fillRect(0,0,w,h);

    // Grid (etwas deutlicher)
    ctx.globalAlpha = 0.7;
    ctx.beginPath();
    for (let x = ox; x < w; x += tile) { ctx.moveTo(x, 0); ctx.lineTo(x, h); }
    for (let y = oy; y < h; y += tile) { ctx.moveTo(0, y); ctx.lineTo(w, y); }
    ctx.strokeStyle = 'rgba(255,255,255,0.07)';
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.globalAlpha = 1;
  }

  function drawTrail(w, h, nowSec){
    if (TRAIL.points.length === 1){
      // Startpunkt als Punkt anzeigen
      const p = toScreen(TRAIL.points[0].x, TRAIL.points[0].y, w, h);
      ctx.save();
      ctx.fillStyle = 'rgba(155,179,255,0.9)';
      ctx.beginPath();
      ctx.arc(p.x, p.y, 3, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
      return;
    }
    if (TRAIL.points.length < 2) return;

    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.save();
    for (let i = 1; i < TRAIL.points.length; i++){
      const a = TRAIL.points[i-1];
      const b = TRAIL.points[i];

      if (a.break || b.break) continue;

      const pa = toScreen(a.x, a.y, w, h);
      const pb = toScreen(b.x, b.y, w, h);

      if (Math.abs(pb.x - pa.x) > Math.max(w, WORLD.width)/2 ||
          Math.abs(pb.y - pa.y) > Math.max(h, WORLD.height)/2) {
        continue;
      }

      const age = nowSec - b.t;
      const alpha = Math.max(0, 1 - (age / TRAIL.fadeSeconds));
      if (alpha <= 0) continue;

      ctx.globalAlpha = alpha * 0.95;
      ctx.strokeStyle = 'rgba(155,179,255,1)';
      ctx.lineWidth = 2 + Math.max(0, 6 * (1 - age / TRAIL.fadeSeconds));

      ctx.beginPath();
      ctx.moveTo(pa.x, pa.y);
      ctx.lineTo(pb.x, pb.y);
      ctx.stroke();
    }
    ctx.restore();

    const cutoff = nowSec - TRAIL.fadeSeconds - 0.1;
    while (TRAIL.points.length && TRAIL.points[0].t < cutoff) TRAIL.points.shift();
  }

  function toScreen(px, py, w, h){
    let dx = px - camera.x;
    let dy = py - camera.y;
    if (dx >  WORLD.width/2)  dx -= WORLD.width;
    if (dx < -WORLD.width/2)  dx += WORLD.width;
    if (dy >  WORLD.height/2) dy -= WORLD.height;
    if (dy < -WORLD.height/2) dy += WORLD.height;
    return { x: w/2 + dx, y: h/2 + dy };
  }

  function drawItems(w, h){
    drawnRects.length = 0;
    for (const it of items){
      if(!it.img) continue;
      const vx = it.x - camera.x;
      const vy = it.y - camera.y;

      const candidates = [
        { dx: 0, dy: 0 }, { dx: WORLD.width, dy: 0 }, { dx: -WORLD.width, dy: 0 },
        { dx: 0, dy: WORLD.height }, { dx: 0, dy: -WORLD.height },
        { dx: WORLD.width, dy: WORLD.height }, { dx: -WORLD.width, dy: -WORLD.height },
        { dx: WORLD.width, dy: -WORLD.height }, { dx: -WORLD.width, dy: WORLD.height },
      ];

      for (const c of candidates){
        const sx = vx + c.dx + w/2;
        const sy = vy + c.dy + h/2;
        if (sx + it.w < -50 || sx > w + 50 || sy + it.h < -50 || sy > h + 50) continue;

        ctx.shadowColor = 'rgba(0,0,0,0.4)';
        ctx.shadowBlur = 18; ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 8;
        const r = 12;
        roundImage(ctx, it.img, sx, sy, it.w, it.h, r);
        ctx.shadowBlur = 0; ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 0;

        ctx.strokeStyle = 'rgba(255,255,255,0.15)';
        ctx.lineWidth = 1;
        roundRectStroke(ctx, sx, sy, it.w, it.h, r);

        drawnRects.push({ x: sx, y: sy, w: it.w, h: it.h, item: it });
      }
    }
  }

  function roundImage(ctx, img, x, y, w, h, r){
    ctx.save();
    roundRectPath(ctx, x, y, w, h, r);
    ctx.clip();
    ctx.drawImage(img, x, y, w, h);
    ctx.restore();
  }
  function roundRectStroke(ctx, x, y, w, h, r){ ctx.save(); roundRectPath(ctx, x, y, w, h, r); ctx.stroke(); ctx.restore(); }
  function roundRectPath(ctx, x, y, w, h, r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y,   x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x,   y+h, rr);
    ctx.arcTo(x,   y+h, x,   y,   rr);
    ctx.arcTo(x,   y,   x+w, y,   rr);
    ctx.closePath();
  }

  function drawMinimap(){
    const w = miniCanvas.width / dpr, h = miniCanvas.height / dpr;
    miniCtx.clearRect(0,0,w,h);
    miniCtx.fillStyle = 'rgba(255,255,255,0.04)';
    miniCtx.fillRect(0,0,w,h);
    miniCtx.strokeStyle = 'rgba(255,255,255,0.12)';
    miniCtx.strokeRect(0,0,w,h);

    const scaleX = w / WORLD.width;
    const scaleY = h / WORLD.height;

    miniCtx.fillStyle = 'rgba(155,179,255,0.7)';
    for (const it of items){
      const px = it.x * scaleX; const py = it.y * scaleY;
      miniCtx.fillRect(px-1, py-1, 2, 2);
    }

    // Trail grob
    miniCtx.beginPath();
    for (let i=0;i<TRAIL.points.length;i++){
      const p = TRAIL.points[i];
      const x = p.x * scaleX, y = p.y * scaleY;
      if (i===0 || p.break) miniCtx.moveTo(x,y); else miniCtx.lineTo(x,y);
    }
    miniCtx.strokeStyle = 'rgba(255,214,102,0.6)';
    miniCtx.lineWidth = 1;
    miniCtx.stroke();

    // Kamera
    miniCtx.fillStyle = '#ffd166';
    miniCtx.beginPath();
    miniCtx.arc(camera.x * scaleX, camera.y * scaleY, 3, 0, Math.PI*2);
    miniCtx.fill();
  }

  // ============ MAIN LOOP ============
  let last = performance.now();

  function tick(now){
    const dt = (now - last) / 1000; last = now;
    update(dt);
    render();
    requestAnimationFrame(tick);
  }

  function update(dt){
    let vx = 0, vy = 0;
    if (keys.has('left'))  vx -= MOVE_SPEED;
    if (keys.has('right')) vx += MOVE_SPEED;
    if (keys.has('up'))    vy -= MOVE_SPEED;
    if (keys.has('down'))  vy += MOVE_SPEED;
    if (vx || vy){
      camera.x += vx * dt;
      camera.y += vy * dt;
      registerTrailSample(true, dt);
      wrapCamera();
    } else {
      // auch ohne Tastatur: periodisch sampeln (für Dragging/Scroll)
      registerTrailSample(false, dt);
    }
  }

  function render(){
    const w = canvas.clientWidth, h = canvas.clientHeight;
    drawBackground(w, h);
    drawTrail(w, h, performance.now()/1000);
    drawItems(w, h);
    drawMinimap();
  }

  // Start: Bilder laden, Kamera auf erstes Bild setzen, Startpunkt setzen
  loadAll().then(()=>{
    if (items.length){
      camera.x = items[0].x;
      camera.y = items[0].y;
      // zwei Punkte für sofort sichtbare Spur
      const t = performance.now()/1000;
      TRAIL.points.push({ x: camera.x, y: camera.y, t, break: false });
      TRAIL.points.push({ x: camera.x + 0.1, y: camera.y + 0.1, t, break: false });
    } else {
      camera.x = WORLD.width/2; camera.y = WORLD.height/2;
      TRAIL.points.push({ x: camera.x, y: camera.y, t: performance.now()/1000, break: false });
    }
    requestAnimationFrame(tick);
  });
  </script>
</body>
</html>
